# 第四章 Python对象

#### 1. 对象(所有Python对象拥有三个特性: 身份, 类型, 值)

* 身份: 没一个对象都有一个唯一的身份标识自己, 任何对象的身份可以使用内建函数 id() 来得到, 这个值可以被理解为对象的内存地址

* 类型: 对象的类型决定了对象可以保存什么值, 可以使用type()查看对象的类型, 所以type()返回的是对象而不是简单的字符串

* 值: 对象表示的数据项


#### 2. 标准类型
* Integer 整数
* Boolean 布尔类型
* Long Integer 长整型
* Floating point real number 浮点型
* Complex number 复数型
* String 字符串
* List 列表
* Tuple 元组
* Dictionary 字典

#### 3.其他内建类型
* 类型
    内建函数`type(obj)`会返回对象的类型, `type(type(obj))` 会返回一个类型的类型

* Null对象(None)
    Python有一种特殊的类型, 被称为Null对象或者NoneType, 他们仅有一个值`None`, 他们没有任何内建方法. None没有任何的属性, 他的布尔值总是False

* 文件
* 集合/固定集合
* 函数/方法
* 模块
* 类


* 布尔值, 所有的对象都可以用于布尔测试, 同类型的对象可以比较大小, 每个对象天生具有布尔True或者False值. 下列值都是False
    1. None
    2. False
    3. 0
    4. 0.0
    5. 0L
    6. 0.0 + 0.0j
    7. ""
    8. []
    9. ()
    10. {}





#### 4. 内部类型
* 代码
    代码对象是编译过的Python源代码片段, 它是可执行对象. 通过内建函数compile()可以得到代码对象, 代码对象可以被exec命令或者eval()内建函数来执行
* 帧
    帧对象表示Python的执行栈帧, 帧对象包含Python解释其在运行时所需要知道的所有信息. 它的属性包括指向上一帧的链接, 正在被执行的代码对象, 本地及全局变量名称空间字典及当前指令等. 每次函数调用产生一个新的帧, 每一帧对象都会相应创建一个C栈帧. 用到帧对象的一个地方是跟踪记录对象
* 跟踪记录
    异常发生时, 一个包含针对异常的栈跟踪信息的跟踪记录对象被创建, 如果一个异常有自己的处理程序, 处理程序就可以访问这个跟踪记录对象
* 切片
    适当使用Python扩展的切片语法时, 就会创建切片对象
    1. 步进切片
        sequence[start: end: step]
    2. 多维切片
        sequence[start1 : end1, start2 : end2]
    3. 省略切片
        sequence[..., start1: end]
    ```
    foostr = "abcdefg"
    foostr[::-1]
    foostr[::-2]
    ```
* 省略
    省略对象用于扩展切片语法中, 起记号作用. 这个对象在切片语法中表示省略号. 类型Null对象None, 省略对象有一个唯一的名字Ellipsis, 它的布尔值始终为True
* Xrange
    xrange()是内建函数range()的兄弟版本, 用于需要节省内存使用或range()无法完成的超大数据集场合.



#### 5. 标准类型操作符
1. 比较操作符用来判断同类型的对象是否相等, 比较运算返回布尔值True或者False

2. Python不同其他语言, 多个操作比较符可以在同一行上进行, 求值为从左到右
```
3 < 4 < 5

4 > 3 == 3
```

3. 对象身份比较操作符, `obj1 is obj2`判断obj1和obj2是用一个对象, 等同于`id(obj1) == id(obj2)`, `obj1 is not obj2` 判断obj1和obj2不是用一个对象, 等同于`id(obj1) != id(obj2)`
    * 下面的例子不同是因为, Python只缓存了简单整型
    ```
    a = 1.0
    b = 1.0
    id(a)
    id(b)
    ```

4. 布尔类型
    1. not expr: expr的逻辑非
    2. expr1 and expr2: expr1 和expr2的逻辑与
    3. expr1 or expr2: expr1 和 expr2 的逻辑或
    * `3 < 4 < 5` 等同于 `( 3 < 4 ) and ( 4 < 5 )`

5. 标准类型内建函数
    1. cmp(obj1, obj2): 比较obj1 和 obj2 结果返回整型:
        * i < 0 if obj1 < obj2
        * i == 0 if obj1 == obj2
        * i > 0 if obj1 > obj2
        * 如果是自定义类, cmp()会调用该类的`__cmp__()`方法
    2. repr(obj) 或者 `obj`: 返回一个对象的字符串表示形式
        * repr()通常可以用来重新获得该对象, 通常情况下`eval(repr(obj)) == obj`这个等式成立
    3. str(obj): 返回一个适合对象可读性良好的的字符串表示形式
    4. type(obj): 返回一个对象的类型, 并返回这个类型对象



#### 6. 类型工厂函数
1. Python 2.2 统一了类型和类, 原来所有的所谓个内建转换函数像`int()`, `type()`, `list()`等等.. 都变成了工厂函数. 也就是说他们看上去有点像函数, 实质上他们是类. 当你调用它们的时候, 实际上生成了该类型的一个实例.

2. 所有的工厂函数
    * int()
    * long()
    * float()
    * complex()
    * str()
    * unicode()
    * basestring()
    * list()
    * tuple()
    * dict()
    * bool()
    * set()
    * frozenset()
    * object()
    * classmethod()
    * staticmethod()
    * super()
    * property()
    * file()


#### 7. 标准类型的分类
* "基本" 是指这些类型都是Python提供的标准或者核心类型
* "内建" 是由于这些类型是Python默认就提供的
* "数据" 是因为他们用于一般数据存储
* "对象" 是因为对象是数据和功能的默认抽象
* "原始" 是因为这些类型提供的是最底层的粒度数据存储
* "类型" 是因为他们就是数据类型

#### 8. 存储模型
1.以存储模型为标准的类型分类
    1. 标量/原子类型: 数值(所有数值类型), 字符串(全部都是文字)
    2. 容器类型: 列表, 元组, 字典

2. 以更新模型为标准的类型分类
    1. 可变类型: 列表, 字典
    2. 不可变类型: 数字, 字符串, 元组

3. 以访问模型为标准的类型分类
    1. 直接访问: 数字
    2. 顺序访问: 列表, 元组, 字符串
    3. 映射访问: 字典


#### 9. 不支持类型
1. char 或者 byte
2. 指针
3. int vs short vs long
4. float vs double














